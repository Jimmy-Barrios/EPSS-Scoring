<?php
/**
 * EPSS API Class
 * 
 * Handles API calls to the FIRST.org EPSS API
 */
class EPSS_API {
    
    /**
     * API endpoint
     */
    private $api_url = 'https://api.first.org/data/v1/epss';
    
    /**
     * Get EPSS data for a specific CVE
     * 
     * @param string $cve_id The CVE ID to query
     * @return array|WP_Error The EPSS data or a WP_Error on failure
     */
    public function get_epss_data($cve_id) {
        // Log the CVE ID for debugging
        error_log('Getting EPSS data for CVE: ' . $cve_id);
        
        // Build the request URL (add cve parameter)
        $request_url = add_query_arg(array(
            'cve' => $cve_id
        ), $this->api_url);
        
        // Make the API request
        $response = wp_remote_get($request_url, array(
            'timeout' => 15,
            'headers' => array(
                'Accept' => 'application/json'
            )
        ));
        
        // Check for errors
        if (is_wp_error($response)) {
            return $response;
        }
        
        // Get response code
        $response_code = wp_remote_retrieve_response_code($response);
        
        // Check response code
        if ($response_code !== 200) {
            return new WP_Error(
                'epss_api_error',
                'Error retrieving EPSS data: ' . wp_remote_retrieve_response_message($response)
            );
        }
        
        // Get response body
        $body = wp_remote_retrieve_body($response);
        
        // Decode JSON response
        $data = json_decode($body, true);
        
        // Check if decode was successful
        if (is_null($data)) {
            return new WP_Error(
                'epss_api_error',
                'Error decoding EPSS API response'
            );
        }
        
        // Check if data exists
        if (empty($data['data']) || !isset($data['data'][0])) {
            return new WP_Error(
                'epss_not_found',
                'No EPSS data found for the provided CVE ID'
            );
        }
        
        // Process the EPSS data
        $processed_data = $this->process_epss_data($data);
        
        try {
            // Get detailed CVE information from NVD - with error handling
            $cve_details = $this->get_cve_details($cve_id);
            
            // Merge the EPSS data with the CVE details
            $combined_data = array_merge($processed_data, $cve_details);
            
            // Log the combined data for debugging
            error_log('Combined data for ' . $cve_id . ': ' . print_r($combined_data, true));
            
            return $combined_data;
        } catch (Exception $e) {
            // If there's an error with the NIST API, just return the basic EPSS data
            error_log('NIST API error: ' . $e->getMessage() . '. Falling back to basic EPSS data.');
            
            // Add placeholder values for attack vectors to prevent JavaScript errors
            $processed_data['attack_vectors'] = $this->get_default_attack_vectors();
            $processed_data['description'] = 'CVE details unavailable. Basic EPSS score information is displayed.';
            $processed_data['published_date'] = '';
            $processed_data['last_modified'] = '';
            $processed_data['references'] = array();
            
            return $processed_data;
        }
    }
    
    /**
     * Process the raw EPSS data into a more usable format
     * 
     * @param array $raw_data The raw API response data
     * @return array Processed data
     */
    private function process_epss_data($raw_data) {
        $processed_data = array();
        
        // Extract the first data item
        $epss_data = $raw_data['data'][0];
        
        // Get CVE ID
        $processed_data['cve_id'] = isset($epss_data['cve']) ? $epss_data['cve'] : '';
        $processed_data['cve'] = $processed_data['cve_id']; // Add duplicate for compatibility
        
        // Get EPSS score
        $processed_data['epss_score'] = isset($epss_data['epss']) ? floatval($epss_data['epss']) : 0;
        $processed_data['epss'] = $processed_data['epss_score']; // Add duplicate for compatibility
        
        // Get percentile score
        $processed_data['percentile'] = isset($epss_data['percentile']) ? floatval($epss_data['percentile']) : 0;
        
        // Get date
        $processed_data['date'] = isset($epss_data['date']) ? $epss_data['date'] : '';
        
        // Add derived data useful for visualization
        $processed_data['score_percentage'] = $processed_data['epss_score'] * 100;
        
        return $processed_data;
    }
    
    /**
     * Normalize vector values to a 0-1 scale
     * 
     * @param string $value The vector value
     * @return float The normalized value
     */
    private function normalize_vector_value($value) {
        $value = strtoupper($value);
        
        // Convert string values to numeric values between 0 and 1
        switch ($value) {
            case 'NETWORK':
            case 'CHANGED':
            case 'HIGH':
            case 'CRITICAL':
                return 0.9;
            
            case 'ADJACENT':
            case 'REQUIRED':
                return 0.7;
            
            case 'LOCAL':
            case 'MEDIUM':
                return 0.5;
            
            case 'PHYSICAL':
            case 'LOW':
            case 'NONE':
            case 'UNCHANGED':
                return 0.3;
                
            default:
                return 0.5; // Default value
        }
    }
    
    /**
     * Calculate an impact score based on confidentiality, integrity, and availability
     * 
     * @param array $attack_vector The attack vector data
     * @return float The calculated impact score
     */
    private function calculate_impact_score($attack_vector) {
        $c_impact = isset($attack_vector['confidentiality_impact']) ? 
            $this->normalize_vector_value($attack_vector['confidentiality_impact']) : 0.5;
        
        $i_impact = isset($attack_vector['integrity_impact']) ? 
            $this->normalize_vector_value($attack_vector['integrity_impact']) : 0.5;
        
        $a_impact = isset($attack_vector['availability_impact']) ? 
            $this->normalize_vector_value($attack_vector['availability_impact']) : 0.5;
        
        // Average the three impact scores
        return ($c_impact + $i_impact + $a_impact) / 3;
    }
    
    /**
     * Get additional CVE details from NVD
     * 
     * This method gets attack vector information from the NVD API
     * 
     * @param string $cve_id The CVE ID
     * @return array Attack vector details and additional CVE information
     * @throws Exception When the NIST API fails
     */
    private function get_cve_details($cve_id) {
        // NVD API URL
        $nvd_api_url = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
        
        // Build the request URL - ensure we pass the full CVE ID
        $request_url = add_query_arg(array(
            'cveId' => $cve_id
        ), $nvd_api_url);
        
        // Log the NIST API request for debugging
        error_log('NIST API Request URL: ' . $request_url);
        
        // Default result structure with comprehensive data
        $cve_details = array(
            // Basic CVE info
            'description' => 'No description available',
            'published_date' => '',
            'last_modified_date' => '',
            'source' => '',
            
            // CVSS data
            'cvss_version' => '',
            'cvss_vector_string' => '',
            'cvss_base_score' => 0,
            'cvss_base_severity' => 'Unknown',
            
            // Attack vectors (CVSS metrics)
            'attack_vector' => 'Unknown',
            'attack_complexity' => 'Unknown',
            'privileges_required' => 'Unknown',
            'user_interaction' => 'Unknown',
            'scope' => 'Unknown',
            'confidentiality_impact' => 'Unknown',
            'integrity_impact' => 'Unknown',
            'availability_impact' => 'Unknown',
            
            // Weakness info
            'cwe_id' => '',
            'cwe_name' => '',
            
            // References
            'references' => array(),
            
            // Calculated fields for visualization
            'base_score' => 0,
            'base_severity' => 'Unknown',
            'attack_vector_normalized' => array()
        );
        
        try {
            // Make the API request with increased timeout
            $response = wp_remote_get($request_url, array(
                'timeout' => 30, // Increase timeout for NIST API
                'headers' => array(
                    'Accept' => 'application/json'
                )
            ));
            
            // Check for errors
            if (is_wp_error($response)) {
                $error_message = $response->get_error_message();
                error_log('NIST API Error: ' . $error_message);
                throw new Exception('NIST API request failed: ' . $error_message);
            }
            
            // Get response code
            $response_code = wp_remote_retrieve_response_code($response);
            
            // Check response code
            if ($response_code !== 200) {
                $error_message = wp_remote_retrieve_response_message($response);
                error_log('NIST API Response Code: ' . $response_code);
                error_log('NIST API Response Message: ' . $error_message);
                throw new Exception('NIST API returned error code ' . $response_code . ': ' . $error_message);
            }
            
            // Get response body
            $body = wp_remote_retrieve_body($response);
            if (empty($body)) {
                error_log('NIST API Error: Empty response body');
                throw new Exception('NIST API returned empty response');
            }
            
            // Decode JSON response
            $data = json_decode($body, true);
            
            // Check if decode was successful
            if (is_null($data)) {
                $json_error = json_last_error_msg();
                error_log('NIST API Error: Unable to decode JSON response - ' . $json_error);
                throw new Exception('Failed to parse NIST API response: ' . $json_error);
            }
            
            // Check if data is valid
            if (empty($data['vulnerabilities']) || empty($data['vulnerabilities'][0]['cve'])) {
                error_log('NIST API Error: No vulnerability data found for ' . $cve_id);
                throw new Exception('No vulnerability data found in NIST API response');
            }
            
            // Get CVE data
            $cve_data = $data['vulnerabilities'][0]['cve'];
            
            // Extract basic CVE information
            if (isset($cve_data['published'])) {
                $cve_details['published_date'] = $cve_data['published'];
            }
            
            if (isset($cve_data['lastModified'])) {
                $cve_details['last_modified_date'] = $cve_data['lastModified'];
            }
            
            if (isset($cve_data['sourceIdentifier'])) {
                $cve_details['source'] = $cve_data['sourceIdentifier'];
            }
            
            // Extract description
            if (isset($cve_data['descriptions']) && is_array($cve_data['descriptions'])) {
                foreach ($cve_data['descriptions'] as $description) {
                    if (isset($description['lang']) && $description['lang'] === 'en' && isset($description['value'])) {
                        $cve_details['description'] = $description['value'];
                        break;
                    }
                }
            }
            
            // Extract CWE information
            if (isset($cve_data['weaknesses']) && is_array($cve_data['weaknesses'])) {
                foreach ($cve_data['weaknesses'] as $weakness) {
                    if (isset($weakness['description']) && is_array($weakness['description'])) {
                        foreach ($weakness['description'] as $desc) {
                            if (isset($desc['value']) && strpos($desc['value'], 'CWE-') === 0) {
                                $cwe_parts = explode(':', $desc['value'], 2);
                                $cve_details['cwe_id'] = trim($cwe_parts[0]);
                                $cve_details['cwe_name'] = isset($cwe_parts[1]) ? trim($cwe_parts[1]) : '';
                                break 2;
                            }
                        }
                    }
                }
            }
            
            // Extract references
            if (isset($cve_data['references']) && is_array($cve_data['references'])) {
                foreach ($cve_data['references'] as $reference) {
                    if (isset($reference['url'])) {
                        $ref_url = $reference['url'];
                        // Only include the URL directly, not as an array
                        $cve_details['references'][] = $ref_url;
                    }
                }
            }
            
            // Extract CVSS data
            if (!$this->extract_cvss_data($cve_data, $cve_details)) {
                // If no CVSS data could be extracted, use default values
                $this->set_default_attack_vectors($cve_details);
            }
            
            return $cve_details;
            
        } catch (Exception $e) {
            // Log the error and re-throw it to be caught by the caller
            error_log('NIST API Processing Error: ' . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Extract CVSS data from CVE data
     * 
     * @param array $cve_data The CVE data from NIST API
     * @param array &$cve_details The CVE details array to update
     * @return bool Whether CVSS data was extracted successfully
     */
    private function extract_cvss_data($cve_data, &$cve_details) {
        // Try CVSS v3.x first
        if (isset($cve_data['metrics']['cvssMetricV3']) && 
            is_array($cve_data['metrics']['cvssMetricV3']) && 
            !empty($cve_data['metrics']['cvssMetricV3'][0]['cvssData'])) {
            
            $cvss_data = $cve_data['metrics']['cvssMetricV3'][0]['cvssData'];
            
            // Extract CVSS metadata
            $cve_details['cvss_version'] = isset($cvss_data['version']) ? $cvss_data['version'] : '3.1';
            $cve_details['cvss_vector_string'] = isset($cvss_data['vectorString']) ? $cvss_data['vectorString'] : '';
            $cve_details['cvss_base_score'] = isset($cvss_data['baseScore']) ? floatval($cvss_data['baseScore']) : 0;
            $cve_details['cvss_base_severity'] = isset($cvss_data['baseSeverity']) ? $cvss_data['baseSeverity'] : 'Unknown';
            
            // Extract attack vectors
            $cve_details['attack_vector'] = isset($cvss_data['attackVector']) ? $cvss_data['attackVector'] : 'Unknown';
            $cve_details['attack_complexity'] = isset($cvss_data['attackComplexity']) ? $cvss_data['attackComplexity'] : 'Unknown';
            $cve_details['privileges_required'] = isset($cvss_data['privilegesRequired']) ? $cvss_data['privilegesRequired'] : 'Unknown';
            $cve_details['user_interaction'] = isset($cvss_data['userInteraction']) ? $cvss_data['userInteraction'] : 'Unknown';
            $cve_details['scope'] = isset($cvss_data['scope']) ? $cvss_data['scope'] : 'Unknown';
            $cve_details['confidentiality_impact'] = isset($cvss_data['confidentialityImpact']) ? $cvss_data['confidentialityImpact'] : 'Unknown';
            $cve_details['integrity_impact'] = isset($cvss_data['integrityImpact']) ? $cvss_data['integrityImpact'] : 'Unknown';
            $cve_details['availability_impact'] = isset($cvss_data['availabilityImpact']) ? $cvss_data['availabilityImpact'] : 'Unknown';
            
            // Set base score and severity for compatibility
            $cve_details['base_score'] = $cve_details['cvss_base_score'];
            $cve_details['base_severity'] = $cve_details['cvss_base_severity'];
            
            return true;
        }
        // Fallback to v2 if v3 is not available
        else if (isset($cve_data['metrics']['cvssMetricV2']) && 
                is_array($cve_data['metrics']['cvssMetricV2']) && 
                !empty($cve_data['metrics']['cvssMetricV2'][0]['cvssData'])) {
            
            $cvss_data = $cve_data['metrics']['cvssMetricV2'][0]['cvssData'];
            
            // Extract CVSS metadata
            $cve_details['cvss_version'] = isset($cvss_data['version']) ? $cvss_data['version'] : '2.0';
            $cve_details['cvss_vector_string'] = isset($cvss_data['vectorString']) ? $cvss_data['vectorString'] : '';
            $cve_details['cvss_base_score'] = isset($cvss_data['baseScore']) ? floatval($cvss_data['baseScore']) : 0;
            $cve_details['cvss_base_severity'] = isset($cvss_data['baseSeverity']) ? $cvss_data['baseSeverity'] : 'Unknown';
            
            // Map CVSS v2 to v3-like structure for consistency
            $cve_details['attack_vector'] = isset($cvss_data['accessVector']) ? 
                $this->map_cvss2_to_cvss3('accessVector', $cvss_data['accessVector']) : 'Unknown';
            $cve_details['attack_complexity'] = isset($cvss_data['accessComplexity']) ? 
                $this->map_cvss2_to_cvss3('accessComplexity', $cvss_data['accessComplexity']) : 'Unknown';
            $cve_details['privileges_required'] = isset($cvss_data['authentication']) ? 
                $this->map_cvss2_to_cvss3('authentication', $cvss_data['authentication']) : 'Unknown';
            $cve_details['user_interaction'] = 'Unknown'; // Not directly mapped in v2
            $cve_details['scope'] = 'UNCHANGED'; // Not in v2
            $cve_details['confidentiality_impact'] = isset($cvss_data['confidentialityImpact']) ? 
                $this->map_cvss2_to_cvss3('confidentialityImpact', $cvss_data['confidentialityImpact']) : 'Unknown';
            $cve_details['integrity_impact'] = isset($cvss_data['integrityImpact']) ? 
                $this->map_cvss2_to_cvss3('integrityImpact', $cvss_data['integrityImpact']) : 'Unknown';
            $cve_details['availability_impact'] = isset($cvss_data['availabilityImpact']) ? 
                $this->map_cvss2_to_cvss3('availabilityImpact', $cvss_data['availabilityImpact']) : 'Unknown';
            
            // Set base score and severity for compatibility
            $cve_details['base_score'] = $cve_details['cvss_base_score'];
            $cve_details['base_severity'] = $cve_details['cvss_base_severity'];
            
            return true;
        }
        
        return false;
    }
    
    /**
     * Set default attack vector values
     * 
     * @param array &$cve_details The CVE details array to update
     */
    private function set_default_attack_vectors(&$cve_details) {
        // Create normalized attack vector values for visualization (0-1 scale)
        $vectors = $this->get_default_attack_vectors();
        
        // Set the values in the cve_details array
        foreach ($vectors as $key => $value) {
            $cve_details[$key] = ucfirst(str_replace('_', ' ', $key));
        }
        
        // Also set the normalized array
        $cve_details['attack_vector_normalized'] = [
            'Attack Vector' => $vectors['attack_vector'],
            'Attack Complexity' => $vectors['attack_complexity'],
            'Privileges Required' => $vectors['privileges_required'],
            'User Interaction' => $vectors['user_interaction'],
            'Confidentiality Impact' => $vectors['confidentiality_impact'],
            'Integrity Impact' => $vectors['integrity_impact'],
            'Availability Impact' => $vectors['availability_impact']
        ];
    }
    
    /**
     * Map CVSS v2 values to CVSS v3 equivalents for consistency
     * 
     * @param string $metric The CVSS v2 metric name
     * @param string $value The CVSS v2 value
     * @return string The equivalent CVSS v3 value
     */
    private function map_cvss2_to_cvss3($metric, $value) {
        $mappings = array(
            'accessVector' => array(
                'NETWORK' => 'NETWORK',
                'ADJACENT_NETWORK' => 'ADJACENT',
                'LOCAL' => 'LOCAL'
            ),
            'accessComplexity' => array(
                'HIGH' => 'HIGH',
                'MEDIUM' => 'MEDIUM',
                'LOW' => 'LOW'
            ),
            'authentication' => array(
                'MULTIPLE' => 'HIGH',
                'SINGLE' => 'LOW',
                'NONE' => 'NONE'
            ),
            'confidentialityImpact' => array(
                'NONE' => 'NONE',
                'PARTIAL' => 'LOW',
                'COMPLETE' => 'HIGH'
            ),
            'integrityImpact' => array(
                'NONE' => 'NONE',
                'PARTIAL' => 'LOW',
                'COMPLETE' => 'HIGH'
            ),
            'availabilityImpact' => array(
                'NONE' => 'NONE',
                'PARTIAL' => 'LOW',
                'COMPLETE' => 'HIGH'
            )
        );
        
        if (isset($mappings[$metric]) && isset($mappings[$metric][$value])) {
            return $mappings[$metric][$value];
        }
        
        return $value;
    }
    
    /**
     * Get default attack vectors for fallback
     *
     * @return array Default attack vectors
     */
    private function get_default_attack_vectors() {
        return [
            'attack_vector' => 0.5,
            'attack_complexity' => 0.5,
            'privileges_required' => 0.5,
            'user_interaction' => 0.5,
            'confidentiality_impact' => 0.5,
            'integrity_impact' => 0.5,
            'availability_impact' => 0.5
        ];
    }
} 