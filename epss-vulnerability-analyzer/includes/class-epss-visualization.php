<?php
/**
 * EPSS Visualization Class
 * 
 * Handles the visualization of EPSS data
 */
class EPSS_Visualization {
    
    /**
     * Cache expiration time in seconds
     */
    private $cache_expiration = 86400; // 24 hours
    
    /**
     * Rate limit for API requests in seconds
     */
    private $rate_limit = 5; // 5 seconds between requests

    /**
     * Validates input data structure
     *
     * @param array $data Data to validate
     * @param array $required_fields Required fields that must exist
     * @return bool|WP_Error True if valid, WP_Error otherwise
     */
    private function validate_data($data, $required_fields = array()) {
        if (!is_array($data)) {
            return new WP_Error('invalid_data', 'Invalid data structure');
        }
        
        // Check for required fields
        if (!empty($required_fields)) {
            foreach ($required_fields as $field) {
                if (!isset($data[$field])) {
                    return new WP_Error('missing_field', sprintf('Required field "%s" is missing', $field));
                }
            }
        }
        
        return true;
    }
    
    /**
     * Generate the HTML output for the visualization
     * 
     * @param array $epss_data The EPSS data to visualize
     * @return string HTML output
     */
    public function generate_visualization($epss_data) {
        // Validate input data
        $validation = $this->validate_data($epss_data, array('cve'));
        if (is_wp_error($validation)) {
            error_log('EPSS Visualization Error: ' . $validation->get_error_message());
            return '<div class="epss-error">Error: Invalid data structure.</div>';
        }
        
        // Get the CVE ID from the data
        $cve_id = isset($epss_data['cve']) ? sanitize_text_field($epss_data['cve']) : 'Unknown';

        // Format the EPSS score as a percentage with 2 decimal places
        $epss_score          = isset($epss_data['epss']) && is_numeric($epss_data['epss']) ? floatval($epss_data['epss']) * 100 : 0;
        $formatted_epss      = number_format($epss_score, 2) . '%';
        $formatted_percentile = isset($epss_data['percentile']) && is_numeric($epss_data['percentile']) ? number_format($epss_data['percentile'] * 100, 2) . '%' : 'N/A';

        // Determine severity class based on EPSS score
        $severity_class = $this->get_severity_class($epss_score);

        // Start output buffering
        ob_start();

        // Generate the HTML output for the visualization
        ?>
        <div class="epss-results-container" aria-live="polite">
            <h3><?php echo esc_html($cve_id); ?> - EPSS Assessment</h3>
            
            <div class="epss-score-container">
                <div class="epss-score">
                    <span class="epss-score-label">EPSS Score:</span>
                    <span class="epss-score-value <?php echo esc_attr($severity_class); ?>"><?php echo esc_html($formatted_epss); ?></span>
                </div>
                <div class="epss-percentile">
                    <span class="epss-percentile-label">Percentile:</span>
                    <span class="epss-percentile-value"><?php echo esc_html($formatted_percentile); ?></span>
                </div>
            </div>
            
            <?php if (isset($epss_data['attack_vector']) && !empty($epss_data['attack_vector'])) : ?>
                <div class="epss-attack-vectors">
                    <h4>Attack Vector Details</h4>
                    <div class="attack-vector-chart-container">
                        <canvas id="attackVectorChart" class="chart-dark-theme" width="400" height="400"></canvas>
                    </div>
                </div>
            <?php endif; ?>
            
            <div class="epss-explanation">
                <p><strong>EPSS Score:</strong> The Exploit Prediction Scoring System (EPSS) score represents the probability that this vulnerability will be exploited in the wild within the next 30 days.</p>
                <p><strong>Percentile:</strong> This vulnerability ranks in the top <?php echo esc_html($formatted_percentile); ?> of all vulnerabilities based on likelihood of exploitation.</p>
            </div>
        </div>
        
        <?php if (isset($epss_data['attack_vector']) && !empty($epss_data['attack_vector'])) : ?>
        <script nonce="<?php echo esc_attr(wp_create_nonce('epss_charts_js')); ?>">
        document.addEventListener('DOMContentLoaded', function() {
            var ctx = document.getElementById('attackVectorChart').getContext('2d');
            
            // Validate and sanitize data before use
            var attackVectorData = <?php 
                $safe_data = array();
                foreach ($epss_data['attack_vector'] as $key => $value) {
                    $safe_key = sanitize_text_field($key);
                    $safe_value = is_numeric($value) ? floatval($value) : 0;
                    $safe_data[$safe_key] = $safe_value;
                }
                echo wp_json_encode($safe_data); 
            ?>;
            
            var labels = Object.keys(attackVectorData);
            var data = Object.values(attackVectorData).map(function(value) {
                return value * 100; // Convert to percentage
            });
            
            // Create the radar chart with dark theme settings
            var attackVectorChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Attack Vector Score (%)',
                        data: data,
                        backgroundColor: 'rgba(126, 222, 59, 0.15)',
                        borderColor: 'rgba(126, 222, 59, 0.8)',
                        pointBackgroundColor: '#000',
                        pointBorderColor: 'rgba(126, 222, 59, 1)',
                        pointHoverBackgroundColor: '#000',
                        pointHoverBorderColor: '#7ede3b',
                        borderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            backgroundColor: 'rgba(0, 0, 0, 0.2)',
                            angleLines: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            pointLabels: {
                                color: '#e0e0e0',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#aaa',
                                backdropColor: 'transparent',
                                showLabelBackdrop: false,
                                z: 1
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: {
                                    size: 14
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#e0e0e0',
                            bodyColor: '#cccccc',
                            borderColor: '#333',
                            borderWidth: 1,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            padding: 10,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return ' Score: ' + context.formattedValue + '%';
                                }
                            }
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.1
                        }
                    }
                }
            });
        });
        </script>
        <?php endif; ?>
        
        <?php
        // Return the buffered output
        return ob_get_clean();
    }

    /**
     * Get severity class based on EPSS score
     * 
     * @param float $score The EPSS score
     * @return string The severity class
     */
    private function get_severity_class($score) {
        if ($score >= 0.7) {
            return 'severity-critical';
        } elseif ($score >= 0.4) {
            return 'severity-high';
        } elseif ($score >= 0.2) {
            return 'severity-medium';
        } else {
            return 'severity-low';
        }
    }

    /**
     * Get severity class based on severity name
     * 
     * @param string $severity The severity name
     * @return string The severity class
     */
    private function get_severity_class_by_name($severity) {
        $severity = strtoupper($severity);
        switch ($severity) {
            case 'CRITICAL':
                return 'severity-critical';
            case 'HIGH':
                return 'severity-high';
            case 'MEDIUM':
                return 'severity-medium';
            case 'LOW':
                return 'severity-low';
            default:
                return '';
        }
    }

    /**
     * Extract attack vectors from EPSS data
     *
     * @param array $epss_data The EPSS data array
     * @return array Extracted attack vectors
     */
    private function extract_attack_vectors($epss_data) {
        $vectors = [];
        
        // Check if attack vectors exist in the data
        if (isset($epss_data['attack_vectors']) && is_array($epss_data['attack_vectors'])) {
            return $epss_data['attack_vectors'];
        }
        
        // Check if normalized attack vectors exist
        if (isset($epss_data['attack_vector_normalized']) && is_array($epss_data['attack_vector_normalized'])) {
            $normalized = $epss_data['attack_vector_normalized'];
            
            // Convert to our standard format
            if (isset($normalized['Attack Vector'])) $vectors['attack_vector'] = $normalized['Attack Vector'];
            if (isset($normalized['Attack Complexity'])) $vectors['attack_complexity'] = $normalized['Attack Complexity'];
            if (isset($normalized['Privileges Required'])) $vectors['privileges_required'] = $normalized['Privileges Required'];
            if (isset($normalized['User Interaction'])) $vectors['user_interaction'] = $normalized['User Interaction'];
            if (isset($normalized['Confidentiality Impact'])) $vectors['confidentiality_impact'] = $normalized['Confidentiality Impact'];
            if (isset($normalized['Integrity Impact'])) $vectors['integrity_impact'] = $normalized['Integrity Impact'];
            if (isset($normalized['Availability Impact'])) $vectors['availability_impact'] = $normalized['Availability Impact'];
            
            if (!empty($vectors)) {
                return $vectors;
            }
        }
        
        // If no attack vectors were explicitly set, try to extract from CVSS vector string
        if (isset($epss_data['cvss_vector_string']) && !empty($epss_data['cvss_vector_string'])) {
            $vector_string = $epss_data['cvss_vector_string'];
            
            // Parse CVSS vector string
            $vector_parts = explode('/', $vector_string);
            foreach ($vector_parts as $part) {
                if (empty($part)) continue;
                
                $part_elements = explode(':', $part);
                if (count($part_elements) != 2) continue;
                
                list($metric, $value) = $part_elements;
                
                // Map CVSS metrics to our attack vector factors
                switch ($metric) {
                    case 'AV': // Attack Vector
                        $vectors['attack_vector'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'AC': // Attack Complexity
                        $vectors['attack_complexity'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'PR': // Privileges Required
                        $vectors['privileges_required'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'UI': // User Interaction
                        $vectors['user_interaction'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'C': // Confidentiality Impact
                        $vectors['confidentiality_impact'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'I': // Integrity Impact
                        $vectors['integrity_impact'] = $this->normalize_cvss_value($metric, $value);
                        break;
                    case 'A': // Availability Impact
                        $vectors['availability_impact'] = $this->normalize_cvss_value($metric, $value);
                        break;
                }
            }
        }
        
        // Check for individual attack vector components as direct properties
        $direct_mappings = [
            'attack_vector' => 'attack_vector',
            'attack_complexity' => 'attack_complexity',
            'privileges_required' => 'privileges_required',
            'user_interaction' => 'user_interaction',
            'confidentiality_impact' => 'confidentiality_impact',
            'integrity_impact' => 'integrity_impact',
            'availability_impact' => 'availability_impact'
        ];
        
        foreach ($direct_mappings as $vector_key => $data_key) {
            if (isset($epss_data[$data_key]) && !isset($vectors[$vector_key])) {
                // If it's a string, try to normalize it
                if (is_string($epss_data[$data_key])) {
                    $vectors[$vector_key] = $this->normalize_vector_value($epss_data[$data_key]);
                } 
                // If it's already a number between 0-1, use it directly
                else if (is_numeric($epss_data[$data_key]) && $epss_data[$data_key] >= 0 && $epss_data[$data_key] <= 1) {
                    $vectors[$vector_key] = floatval($epss_data[$data_key]);
                }
            }
        }
        
        // If we still don't have vectors, check for individual CVSS metrics
        $vector_mapping = [
            'cvss_av' => 'attack_vector',
            'cvss_ac' => 'attack_complexity',
            'cvss_pr' => 'privileges_required',
            'cvss_ui' => 'user_interaction',
            'cvss_c' => 'confidentiality_impact',
            'cvss_i' => 'integrity_impact',
            'cvss_a' => 'availability_impact'
        ];
        
        foreach ($vector_mapping as $cvss_key => $vector_key) {
            if (isset($epss_data[$cvss_key]) && !isset($vectors[$vector_key])) {
                $vectors[$vector_key] = $this->normalize_cvss_value($cvss_key, $epss_data[$cvss_key]);
            }
        }
        
        // If still empty, create some placeholder data
        if (empty($vectors)) {
            // Default values for visualization
            $vectors = [
                'attack_vector' => 0.5,
                'attack_complexity' => 0.5,
                'privileges_required' => 0.5,
                'user_interaction' => 0.5,
                'confidentiality_impact' => 0.5,
                'integrity_impact' => 0.5,
                'availability_impact' => 0.5
            ];
            
            // Log that we're using default data
            error_log('Using default attack vector data for visualization');
        }
        
        return $vectors;
    }
    
    /**
     * Normalize string vector values to a 0-1 scale
     * 
     * @param string $value The vector value to normalize
     * @return float Normalized value between 0 and 1
     */
    private function normalize_vector_value($value) {
        if (is_numeric($value) && $value >= 0 && $value <= 1) {
            return floatval($value);
        }
        
        $value = strtoupper(trim($value));
        
        // Check for CVSS vector values
        switch ($value) {
            case 'NETWORK':
            case 'N':
            case 'NONE':
            case 'HIGH':
            case 'H':
            case 'COMPLETE':
            case 'CRITICAL':
                return 0.9;
                
            case 'ADJACENT':
            case 'A':
            case 'CHANGED':
            case 'MEDIUM':
            case 'M':
                return 0.7;
                
            case 'LOCAL':
            case 'L':
            case 'LOW':
            case 'PARTIAL':
                return 0.4;
                
            case 'PHYSICAL':
            case 'P':
            case 'REQUIRED':
            case 'R':
            case 'UNCHANGED':
                return 0.2;
                
            default:
                // Default to mid-range if not recognized
                return 0.5;
        }
    }

    /**
     * Normalize CVSS values to a 0-1 scale for the chart
     * 
     * @param string $metric The CVSS metric
     * @param string $value The CVSS value
     * @return float Normalized value (0-1)
     */
    private function normalize_cvss_value($metric, $value) {
        // Default value
        $normalized = 0.5;
        
        // Different metrics have different scales
        switch ($metric) {
            case 'AV':
            case 'cvss_av':
                // Attack Vector: N(etwork) > A(djacent) > L(ocal) > P(hysical)
                switch ($value) {
                    case 'N': $normalized = 1.0; break;
                    case 'A': $normalized = 0.7; break;
                    case 'L': $normalized = 0.4; break;
                    case 'P': $normalized = 0.1; break;
                }
                break;
                
            case 'AC':
            case 'cvss_ac':
                // Attack Complexity: L(ow) > H(igh)
                switch ($value) {
                    case 'L': $normalized = 0.9; break;
                    case 'H': $normalized = 0.3; break;
                }
                break;
                
            case 'PR':
            case 'cvss_pr':
                // Privileges Required: N(one) > L(ow) > H(igh)
                switch ($value) {
                    case 'N': $normalized = 1.0; break;
                    case 'L': $normalized = 0.6; break;
                    case 'H': $normalized = 0.2; break;
                }
                break;
                
            case 'UI':
            case 'cvss_ui':
                // User Interaction: N(one) > R(equired)
                switch ($value) {
                    case 'N': $normalized = 0.9; break;
                    case 'R': $normalized = 0.3; break;
                }
                break;
                
            case 'C':
            case 'I':
            case 'A':
            case 'cvss_c':
            case 'cvss_i':
            case 'cvss_a':
                // Impact: H(igh) > M(edium) > L(ow) > N(one)
                switch ($value) {
                    case 'H': $normalized = 0.9; break;
                    case 'M': $normalized = 0.6; break;
                    case 'L': $normalized = 0.3; break;
                    case 'N': $normalized = 0.0; break;
                }
                break;
        }
        
        return $normalized;
    }

    /**
     * Format vector value for display
     *
     * @param string $factor The attack vector factor
     * @param float $value The normalized value
     * @return string Formatted value
     */
    private function format_vector_value($factor, $value) {
        // Format based on the factor type
        switch ($factor) {
            case 'attack_vector':
                if ($value >= 0.9) return 'Network';
                if ($value >= 0.6) return 'Adjacent';
                if ($value >= 0.3) return 'Local';
                return 'Physical';
                
            case 'attack_complexity':
                if ($value >= 0.6) return 'Low';
                return 'High';
                
            case 'privileges_required':
                if ($value >= 0.8) return 'None';
                if ($value >= 0.4) return 'Low';
                return 'High';
                
            case 'user_interaction':
                if ($value >= 0.6) return 'None';
                return 'Required';
                
            case 'confidentiality_impact':
            case 'integrity_impact':
            case 'availability_impact':
                if ($value >= 0.8) return 'High';
                if ($value >= 0.5) return 'Medium';
                if ($value >= 0.1) return 'Low';
                return 'None';
                
            default:
                // For other factors, just return the normalized value as percentage
                return number_format($value * 100) . '%';
        }
    }

    /**
     * Fetch references for a CVE from the NIST NVD API
     *
     * @param string $cve_id The CVE ID to fetch references for
     * @return array Array of reference URLs
     */
    private function get_nist_references($cve_id) {
        // Initialize empty references array
        $references = array();
        
        // Ensure CVE ID is correctly formatted
        $cve_id = strtoupper(trim($cve_id));
        if (!preg_match('/^CVE-\d{4}-\d{4,}$/', $cve_id)) {
            error_log('NIST API Error: Invalid CVE ID format: ' . $cve_id);
            return $references;
        }
        
        // Check cache first
        $cache_key = 'epss_nist_ref_' . md5($cve_id);
        $cached_references = get_transient($cache_key);
        
        if (false !== $cached_references) {
            return $cached_references;
        }
        
        // Check rate limit
        $last_request_time = get_transient('epss_nist_last_req');
        if (false !== $last_request_time && (time() - $last_request_time) < $this->rate_limit) {
            $wait_time = $this->rate_limit - (time() - $last_request_time);
            error_log('NIST API: Rate limiting in effect. Waiting ' . $wait_time . ' seconds.');
            sleep($wait_time); // Wait until rate limit passes
        }
        
        // Set the last request time
        set_transient('epss_nist_last_req', time(), 60);
        
        // Format the API URL with the CVE ID
        $api_url = 'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=' . urlencode($cve_id);
        
        error_log('NIST API Request: ' . $api_url);
        
        // Make the request to the NIST API
        $response = wp_remote_get($api_url, array(
            'timeout' => 15,
            'headers' => array(
                'User-Agent' => 'EPSS Vulnerability Analyzer WordPress Plugin/' . (defined('EPSS_ANALYZER_VERSION') ? EPSS_ANALYZER_VERSION : '1.0.0'),
                'Accept' => 'application/json',
            ),
            'sslverify' => true,
        ));
        
        // Check for errors
        if (is_wp_error($response)) {
            error_log('NIST API Error: ' . $response->get_error_message());
            return $references;
        }
        
        // Check HTTP response code
        $http_code = wp_remote_retrieve_response_code($response);
        if ($http_code !== 200) {
            error_log('NIST API Error: HTTP response code ' . $http_code);
            error_log('NIST API Response: ' . wp_remote_retrieve_body($response));
            return $references;
        }
        
        // Get the response body
        $body = wp_remote_retrieve_body($response);
        if (empty($body)) {
            error_log('NIST API Error: Empty response body');
            return $references;
        }
        
        // Parse the JSON
        $data = json_decode($body, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            error_log('NIST API Error: JSON parse error - ' . json_last_error_msg());
            error_log('NIST API Response (truncated): ' . substr($body, 0, 500) . '...');
            return $references;
        }
        
        // Validate data structure
        if (!isset($data['vulnerabilities']) || !is_array($data['vulnerabilities'])) {
            error_log('NIST API Error: Invalid data structure - missing vulnerabilities array');
            return $references;
        }
        
        // Extract references if available
        if (!empty($data['vulnerabilities'])) {
            foreach ($data['vulnerabilities'] as $vulnerability) {
                if (isset($vulnerability['cve']['references']) && !empty($vulnerability['cve']['references'])) {
                    foreach ($vulnerability['cve']['references'] as $reference) {
                        if (isset($reference['url']) && filter_var($reference['url'], FILTER_VALIDATE_URL)) {
                            $references[] = $reference['url'];
                            error_log('NIST Reference added: ' . $reference['url']);
                        }
                    }
                }
            }
        } else {
            // Check for alternative data structures
            if (isset($data['result']) && isset($data['result']['CVE_Items'])) {
                // Handle legacy API format
                foreach ($data['result']['CVE_Items'] as $item) {
                    if (isset($item['cve']['references']['reference_data'])) {
                        foreach ($item['cve']['references']['reference_data'] as $ref) {
                            if (isset($ref['url']) && filter_var($ref['url'], FILTER_VALIDATE_URL)) {
                                $references[] = $ref['url'];
                                error_log('NIST Legacy Reference added: ' . $ref['url']);
                            }
                        }
                    }
                }
            }
        }
        
        error_log('NIST References found: ' . count($references));
        
        // If still no references found, try an alternative endpoint
        if (empty($references)) {
            error_log('NIST API: No references found, trying alternative endpoint');
            
            // Try the CVE Details API
            $fallback_url = 'https://cve.circl.lu/api/cve/' . urlencode($cve_id);
            $fallback_response = wp_remote_get($fallback_url, array(
                'timeout' => 15,
                'sslverify' => true,
                'headers' => array(
                    'User-Agent' => 'EPSS Vulnerability Analyzer WordPress Plugin/' . (defined('EPSS_ANALYZER_VERSION') ? EPSS_ANALYZER_VERSION : '1.0.0'),
                ),
            ));
            
            if (!is_wp_error($fallback_response) && wp_remote_retrieve_response_code($fallback_response) === 200) {
                $fallback_body = wp_remote_retrieve_body($fallback_response);
                $fallback_data = json_decode($fallback_body, true);
                
                if (json_last_error() === JSON_ERROR_NONE && isset($fallback_data['references']) && is_array($fallback_data['references'])) {
                    foreach ($fallback_data['references'] as $ref) {
                        if (filter_var($ref, FILTER_VALIDATE_URL)) {
                            $references[] = $ref;
                            error_log('Fallback Reference added: ' . $ref);
                        }
                    }
                }
            }
        }
        
        // Limit to 10 references maximum
        if (count($references) > 10) {
            $references = array_slice($references, 0, 10);
            error_log('References limited to 10 items');
        }
        
        // Cache the results
        set_transient($cache_key, $references, $this->cache_expiration);
        
        return $references;
    }

    /**
     * Generate HTML for the EPSS analysis results
     *
     * @param array $epss_data The EPSS data array containing all necessary information
     * @return string The HTML for the results
     */
    public function generate_results_html($epss_data) {
        // Validate input data
        $validation = $this->validate_data($epss_data, array('cve_id'));
        if (is_wp_error($validation)) {
            error_log('EPSS Results Error: ' . $validation->get_error_message());
            return '<div class="epss-error">Error: Invalid data structure.</div>';
        }
        
        if (empty($epss_data) || !isset($epss_data['cve_id'])) {
            return '<div class="epss-error">No valid EPSS data available.</div>';
        }
        
        // Extract data from the EPSS data array
        $cve_id = sanitize_text_field($epss_data['cve_id']);
        $epss_score = isset($epss_data['epss']) && is_numeric($epss_data['epss']) ? floatval($epss_data['epss']) : 0;
        $percentile = isset($epss_data['percentile']) && is_numeric($epss_data['percentile']) ? floatval($epss_data['percentile']) : 0;
        
        // Fix CVSS score extraction with multiple fallbacks
        $cvss_score = 0;
        $cvss_severity = 'Unknown';
        
        // Try different possible keys for CVSS score
        if (isset($epss_data['cvss_score']) && is_numeric($epss_data['cvss_score'])) {
            $cvss_score = floatval($epss_data['cvss_score']);
        } elseif (isset($epss_data['cvss3_score']) && is_numeric($epss_data['cvss3_score'])) {
            $cvss_score = floatval($epss_data['cvss3_score']);
        } elseif (isset($epss_data['cvss']) && is_numeric($epss_data['cvss'])) {
            $cvss_score = floatval($epss_data['cvss']);
        } elseif (isset($epss_data['cvss_data']['score']) && is_numeric($epss_data['cvss_data']['score'])) {
            $cvss_score = floatval($epss_data['cvss_data']['score']);
        } elseif (isset($epss_data['base_score']) && is_numeric($epss_data['base_score'])) {
            $cvss_score = floatval($epss_data['base_score']);
        }
        
        // Get CVSS severity with fallbacks
        if (isset($epss_data['cvss_severity']) && !empty($epss_data['cvss_severity'])) {
            $cvss_severity = sanitize_text_field($epss_data['cvss_severity']);
        } elseif (isset($epss_data['cvss3_severity']) && !empty($epss_data['cvss3_severity'])) {
            $cvss_severity = sanitize_text_field($epss_data['cvss3_severity']);
        } elseif (isset($epss_data['severity']) && !empty($epss_data['severity'])) {
            $cvss_severity = sanitize_text_field($epss_data['severity']);
        } elseif (isset($epss_data['cvss_data']['severity']) && !empty($epss_data['cvss_data']['severity'])) {
            $cvss_severity = sanitize_text_field($epss_data['cvss_data']['severity']);
        } elseif ($cvss_score > 0) {
            // Derive severity from score if we have a score but no severity
            $cvss_severity = $this->derive_severity_from_score($cvss_score);
        }
        
        // Debug
        error_log('CVSS Data - Score: ' . $cvss_score . ', Severity: ' . $cvss_severity);
        error_log('EPSS Data Structure: ' . print_r($epss_data, true));
        
        $description = isset($epss_data['description']) ? wp_kses_post($epss_data['description']) : 'No description available';
        $published_date = isset($epss_data['published_date']) ? sanitize_text_field($epss_data['published_date']) : '';
        $last_modified = isset($epss_data['last_modified']) ? sanitize_text_field($epss_data['last_modified']) : '';
        
        // Get references from NIST API instead of EPSS data
        $references = $this->get_nist_references($cve_id);
        
        // Extract attack vectors for radar chart
        $attack_vectors = $this->extract_attack_vectors($epss_data);
        
        // Calculate severity class for styling
        $severity_class = $this->get_severity_class($epss_score);
        
        // Format the dates if they exist
        $published_formatted = !empty($published_date) && strtotime($published_date) ? date('F j, Y', strtotime($published_date)) : 'Unknown';
        $modified_formatted = !empty($last_modified) && strtotime($last_modified) ? date('F j, Y', strtotime($last_modified)) : 'Unknown';
        
        // Generate a nonce for inline scripts
        $script_nonce = wp_create_nonce('epss_inline_js');
        
        // Start building the HTML output
        $html = '<div class="epss-results dark-theme">';
        
        // Header with CVE ID
        $html .= '<h2 class="epss-results-header">Vulnerability Analysis Results for ' . esc_html($cve_id) . '</h2>';
        
        // Main results grid
        $html .= '<div class="epss-results-grid">';
        
        // Left column - CVE information
        $html .= '<div class="epss-results-column">';
        $html .= '<div class="epss-results-section epss-cve-summary">';
        $html .= '<h3>CVE Summary</h3>';
        $html .= '<div class="epss-description">' . $description . '</div>';
        
        // Dates
        $html .= '<div class="epss-dates">';
        $html .= '<div><strong>Published:</strong> ' . esc_html($published_formatted) . '</div>';
        $html .= '<div><strong>Last Modified:</strong> ' . esc_html($modified_formatted) . '</div>';
        $html .= '</div>'; // End dates
        
        $html .= '</div>'; // End CVE summary
        
        $html .= '</div>'; // End left column
        
        // Right column - Scores and visualization
        $html .= '<div class="epss-results-column">';
        
        // Score section - UPDATED DESIGN
        $html .= '<div class="epss-results-section epss-scores">';
        $html .= '<h3>Vulnerability Scores</h3>';
        
        $html .= '<div class="epss-modern-scores-grid">';
        
        // EPSS score - updated design
        $html .= '<div class="epss-modern-score-panel">';
        $html .= '<div class="epss-modern-score-header">EPSS Score</div>';
        $html .= '<div class="epss-modern-score-value">' . number_format($epss_score * 100, 2) . '%</div>';
        $html .= '<div class="epss-modern-score-context">Probability of exploitation in the next 30 days</div>';
        $html .= '</div>'; // End EPSS score panel
        
        // Percentile - updated design
        $html .= '<div class="epss-modern-score-panel">';
        $html .= '<div class="epss-modern-score-header">Percentile</div>';
        $html .= '<div class="epss-modern-score-value">' . number_format($percentile * 100, 2) . '%</div>';
        $html .= '<div class="epss-modern-score-context">Ranked higher than this percentage of vulnerabilities</div>';
        $html .= '</div>'; // End Percentile panel
        
        // CVSS score - updated design
        $html .= '<div class="epss-modern-score-panel">';
        $html .= '<div class="epss-modern-score-header">CVSS Score</div>';
        $html .= '<div class="epss-modern-score-value">' . number_format($cvss_score, 1) . '</div>';
        $html .= '<div class="epss-modern-score-context">Severity: ' . esc_html($cvss_severity) . '</div>';
        $html .= '</div>'; // End CVSS score panel
        
        $html .= '</div>'; // End modern scores grid
        
        $html .= '</div>'; // End scores section
        
        // Add CSS for modern design
        $html .= '<style>
            .epss-modern-scores-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin-top: 15px;
            }
            .epss-modern-score-panel {
                background-color: #0d1117;
                border: 1px solid #21262d;
                border-radius: 6px;
                padding: 20px;
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            .epss-modern-score-header {
                color: #8b949e;
                font-size: 16px;
                margin-bottom: 10px;
                font-weight: 500;
            }
            .epss-modern-score-value {
                color: #ff5252;
                font-size: 32px;
                font-weight: 700;
                margin-bottom: 10px;
            }
            .epss-modern-score-context {
                color: #8b949e;
                font-size: 13px;
                line-height: 1.4;
            }
            .severity-critical .epss-modern-score-value {
                color: #ff5252;
            }
            .severity-high .epss-modern-score-value {
                color: #ff9800;
            }
            .severity-medium .epss-modern-score-value {
                color: #ffca28;
            }
            .severity-low .epss-modern-score-value {
                color: #66bb6a;
            }
        </style>';
        
        // Attack vector analysis
        $html .= '<div class="epss-results-section epss-attack-vectors">';
        
        // Only show the table and chart if we have attack vectors
        if (!empty($attack_vectors)) {
            // Create a single panel layout (removing the grid)
            
            // Prepare radar chart data
            $radar_labels = [];
            $radar_values = [];
            
            foreach ($attack_vectors as $factor => $value) {
                // Format data for radar chart
                $radar_labels[] = ucfirst(str_replace('_', ' ', $factor));
                $radar_values[] = $value;
            }
            
            // Single panel - Radar chart with title
            $html .= '<div class="epss-vector-panel">';
            $html .= '<h4 class="epss-vector-panel-title">Vulnerability Profile</h4>';
            
            // Add the radar chart canvas with correct data - increased dimensions
            $html .= '<div class="epss-radar-chart-container">';
            $html .= '<canvas id="epssRadarChart" 
                     data-labels=\'' . wp_json_encode($radar_labels) . '\' 
                     data-values=\'' . wp_json_encode($radar_values) . '\' 
                     width="600" height="500"></canvas>';
            $html .= '</div>';
            $html .= '</div>'; // End single panel
            
            // Add the radar chart initialization script with unique ID to prevent conflicts
            $unique_id = 'radar_' . wp_rand(1000, 9999) . '_' . time();
            $html .= '<script nonce="' . esc_attr($script_nonce) . '">
                // Wait for DOM to be fully loaded
                jQuery(document).ready(function($) {
                    console.log("DOM ready for radar chart ' . esc_js($unique_id) . '");
                    // Radar chart specific initialization
                    const canvasId = "epssRadarChart";
                    setTimeout(function() {
                        if (document.getElementById(canvasId)) {
                            console.log("Canvas #" + canvasId + " found, ready for chart initialization");
                        } else {
                            console.error("Canvas #" + canvasId + " not found after delay");
                        }
                    }, 100);
                });
            </script>';
            
            // Add CSS for the new design - with larger chart dimensions
            $html .= '<style>
                .epss-vector-panel {
                    background-color: #121212;
                    border: 1px solid #2a2a2a;
                    border-radius: 4px;
                    padding: 15px;
                    position: relative;
                    max-width: 650px;
                    margin: 0 auto;
                }
                .epss-vector-panel-title {
                    color: #e0e0e0;
                    font-size: 16px;
                    margin: 0 0 15px 0;
                    text-align: center;
                    font-weight: 500;
                }
                .epss-radar-chart-container {
                    background-color: #121212;
                    min-height: 450px;
                    max-height: 500px;
                    position: relative;
                }
            </style>';
            
            // Add the radar chart initialization script
            $html .= $this->initialize_radar_chart();
        } else {
            $html .= '<p class="epss-no-data">No attack vector data available.</p>';
        }
        
        $html .= '</div>'; // End attack vectors
        
        // References - MOVED TO AFTER ATTACK VECTORS
        if (!empty($references)) {
            $html .= '<div class="epss-results-section epss-references">';
            $html .= '<h3>References (via NIST)</h3>';
            $html .= '<ul class="epss-reference-list">';
            
            // Display all references (maximum 10 due to limitation in get_nist_references)
            foreach ($references as $ref) {
                $ref_url = esc_url($ref);
                $display_url = preg_replace('(^https?://)', '', $ref_url);
                $html .= '<li><a href="' . $ref_url . '" target="_blank" rel="noopener noreferrer">' . esc_html($display_url) . '</a></li>';
            }
            
            $html .= '</ul>';
            $html .= '</div>'; // End references
        }
        
        $html .= '</div>'; // End right column
        
        $html .= '</div>'; // End results grid
        $html .= '</div>'; // End results
        
        return $html;
    }

    /**
     * Get CSS class for CVSS severity
     *
     * @param string $severity CVSS severity rating
     * @return string CSS class
     */
    private function get_cvss_severity_class($severity) {
        switch (strtolower($severity)) {
            case 'critical':
                return 'severity-critical';
            case 'high':
                return 'severity-high';
            case 'medium':
                return 'severity-medium';
            case 'low':
                return 'severity-low';
            default:
                return 'severity-unknown';
        }
    }

    /**
     * Get human-readable text for factor value
     * 
     * @param string $factor The attack vector factor
     * @param float $value The normalized value (0-1)
     * @return string Human-readable text
     */
    private function get_factor_text_for_value($factor, $value) {
        // Convert factor name format
        $display_factor = str_replace('_', ' ', $factor);
        $display_factor = ucfirst($display_factor);
        
        // Define factor-specific text based on ranges
        $factor_text = array(
            'attack_vector' => array(
                array(0.8, 1.0, 'Network (High Impact)'),
                array(0.5, 0.8, 'Adjacent (Medium Impact)'),
                array(0.2, 0.5, 'Local (Low Impact)'),
                array(0, 0.2, 'Physical (Minimal Impact)')
            ),
            'attack_complexity' => array(
                array(0.6, 1.0, 'Low (High Impact)'),
                array(0, 0.6, 'High (Low Impact)')
            ),
            'privileges_required' => array(
                array(0.8, 1.0, 'None (High Impact)'),
                array(0.4, 0.8, 'Low (Medium Impact)'),
                array(0, 0.4, 'High (Low Impact)')
            ),
            'user_interaction' => array(
                array(0.6, 1.0, 'None (High Impact)'),
                array(0, 0.6, 'Required (Low Impact)')
            ),
            'confidentiality_impact' => array(
                array(0.8, 1.0, 'High Impact'),
                array(0.4, 0.8, 'Medium Impact'),
                array(0.1, 0.4, 'Low Impact'),
                array(0, 0.1, 'None')
            ),
            'integrity_impact' => array(
                array(0.8, 1.0, 'High Impact'),
                array(0.4, 0.8, 'Medium Impact'),
                array(0.1, 0.4, 'Low Impact'),
                array(0, 0.1, 'None')
            ),
            'availability_impact' => array(
                array(0.8, 1.0, 'High Impact'),
                array(0.4, 0.8, 'Medium Impact'),
                array(0.1, 0.4, 'Low Impact'),
                array(0, 0.1, 'None')
            )
        );
        
        // Get factor-specific text ranges
        $ranges = isset($factor_text[$factor]) ? $factor_text[$factor] : null;
        
        if (is_null($ranges)) {
            return number_format($value * 100, 2) . '%';
        }
        
        // Find the appropriate range
        foreach ($ranges as $range) {
            list($min, $max, $text) = $range;
            if ($value >= $min && $value < $max) {
                return $text . ' (' . number_format($value * 100, 2) . '%)';
            }
        }
        
        // Fallback
        return number_format($value * 100, 2) . '%';
    }

    /**
     * Initialize the radar chart with JavaScript
     * 
     * @return string JavaScript code to initialize the radar chart
     */
    public function initialize_radar_chart() {
        // Generate a nonce for script security
        $script_nonce = wp_create_nonce('epss_radar_chart_js');
        
        $script = '<script nonce="' . esc_attr($script_nonce) . '">
            jQuery(document).ready(function($) {
                // Give the DOM time to fully render
                setTimeout(function() {
                    // Check if we have a radar chart element
                    const canvas = document.getElementById("epssRadarChart");
                    if (!canvas) {
                        console.error("Radar chart canvas not found in initialize_radar_chart");
                        return;
                    }
                    
                    // Get data from data attributes
                    try {
                        const labels = JSON.parse(canvas.dataset.labels || "[]");
                        const values = JSON.parse(canvas.dataset.values || "[]");
                        
                        if (!labels.length || !values.length) {
                            console.error("No data available for radar chart");
                            return;
                        }
                        
                        // Validate data
                        const validatedValues = values.map(v => {
                            const num = parseFloat(v);
                            return isNaN(num) ? 0 : Math.min(Math.max(num, 0), 1);
                        });
                        
                        // Load Chart.js if not already loaded
                        if (typeof Chart === "undefined") {
                            console.log("Loading Chart.js dynamically");
                            const script = document.createElement("script");
                            script.src = "https://cdn.jsdelivr.net/npm/chart.js";
                            script.setAttribute("nonce", "' . esc_js($script_nonce) . '");
                            script.onload = function() {
                                console.log("Chart.js loaded, initializing radar chart");
                                initRadarChart(labels, validatedValues);
                            };
                            document.head.appendChild(script);
                        } else {
                            console.log("Chart.js already loaded, initializing radar chart");
                            initRadarChart(labels, validatedValues);
                        }
                    } catch (e) {
                        console.error("Error initializing radar chart:", e);
                    }
                }, 100); // Small delay to ensure DOM is ready
                
                function initRadarChart(labels, values) {
                    try {
                        const canvas = document.getElementById("epssRadarChart");
                        if (!canvas) {
                            console.error("Canvas lost during initialization");
                            return;
                        }
                        
                        const ctx = canvas.getContext("2d");
                        if (!ctx) {
                            console.error("Could not get canvas context");
                            return;
                        }
                        
                        console.log("Creating radar chart with", labels.length, "labels and", values.length, "data points");
                        
                        // Create radar chart
                        const radarChart = new Chart(ctx, {
                            type: "radar",
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: "Attack Vector Impact",
                                    data: values,
                                    backgroundColor: "rgba(126, 222, 59, 0.2)",
                                    borderColor: "rgba(126, 222, 59, 0.8)",
                                    pointBackgroundColor: "rgba(126, 222, 59, 1)",
                                    pointBorderColor: "#121212",
                                    pointHoverBackgroundColor: "#fff",
                                    pointHoverBorderColor: "rgba(126, 222, 59, 1)",
                                    borderWidth: 2,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    r: {
                                        backgroundColor: "#1a1a1a",
                                        min: 0,
                                        max: 1,
                                        ticks: {
                                            backdropColor: "rgba(0, 0, 0, 0)",
                                            color: "#aaa",
                                            stepSize: 0.2,
                                            z: 1
                                        },
                                        angleLines: {
                                            color: "rgba(70, 70, 70, 0.5)",
                                            lineWidth: 1
                                        },
                                        grid: {
                                            color: "rgba(70, 70, 70, 0.3)",
                                            circular: true
                                        },
                                        pointLabels: {
                                            color: "#e0e0e0",
                                            font: {
                                                size: 12
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: "top",
                                        labels: {
                                            color: "#e0e0e0",
                                            font: {
                                                size: 14
                                            },
                                            boxWidth: 15,
                                            padding: 15
                                        }
                                    },
                                    tooltip: {
                                        backgroundColor: "rgba(15, 15, 15, 0.8)",
                                        titleColor: "#7ede3b",
                                        bodyColor: "#e0e0e0",
                                        borderColor: "#444",
                                        borderWidth: 1,
                                        titleFont: {
                                            size: 14,
                                            weight: "bold"
                                        },
                                        bodyFont: {
                                            size: 13
                                        },
                                        padding: 10,
                                        displayColors: false,
                                        callbacks: {
                                            label: function(context) {
                                                return "Impact: " + (context.raw * 100).toFixed(1) + "%";
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Mark the canvas as having a chart
                        canvas._chart = radarChart;
                        console.log("Radar chart initialization successful");
                    } catch (e) {
                        console.error("Error during radar chart creation:", e);
                    }
                }
            });
        </script>';
        
        return $script;
    }

    /**
     * Derive CVSS severity from score
     *
     * @param float $score CVSS score
     * @return string Severity rating
     */
    private function derive_severity_from_score($score) {
        if ($score >= 9.0) {
            return 'Critical';
        } elseif ($score >= 7.0) {
            return 'High';
        } elseif ($score >= 4.0) {
            return 'Medium';
        } elseif ($score > 0) {
            return 'Low';
        } else {
            return 'Unknown';
        }
    }
} 